// OSPF.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include<stdio.h>

#define INFINITY 100                      //赋值最大值

void main()

{

	int tu[11][11], i, j, v0, v, w, min, r = 22, a, b, temp = 0, s1 = 5;

	int final[11], s[6][11], p[11][11], q[11], d[11];       //final[11]是用来记录节点v是否在S集中，s[6][11]用来记录路由到各个网络节点

															   //最短路径上的正序路径;d[11]是各到开始路由的最短路径上的权值

	char str[22] = { 'R','1','R','2','R','3','R','4','R','5','R','6','N','1','N','2','N','3','N','4','N','5' };

	int str1[66] = { 0,3,8,0,6,5,

   1,4,4,1,6,7,

   2,6,3,2,7,2,

   3,0,8,3,8,2,

   4,1,4,4,8,5,

   4,9,2,5,8,9,

   5,10,5,6,0,0,

   6,1,0,6,2,0,

   7,2,0,8,3,0,

   8,4,0,8,5,0,

   9,4,0,10,5,0 };

	//把记录最短路径上各节点的正序顺序值初始化

	for (i = 0; i < 6; i++)

		for (j = 0; j < 11; j++)

			s[i][j] = 100;

	//初步把所有两点之间都初始化为最大值  

	for (i = 0; i < 11; i++)

		for (j = 0; j < 11; j++)

		{

			if (j == i)

				tu[i][j] = 0;

			else

				tu[i][j] = INFINITY;

		}



	//按照题目给出的数据重新初始化列表

	for (i = 0; i < 22; i++)

	{

		a = str1[3 * i];                       //列表中的行数

		b = str1[3 * i + 1];                     //列表中的列数

		tu[a][b] = str1[3 * i + 2];              //列表中对应的数值 

	}

	//打印出网络和路由间对应的列表关系

	printf("\n    R1   R2   R3   R4   R5   R6   N1   N2   N3   N4   N5\n");

	printf("   ----------------------------------------------------------------------------\n");

	for (i = 0; i < 11; i++)

	{

		printf("%c", str[2 * i]);

		printf("%c", str[2 * i + 1]);

		for (j = 0; j < 11; j++)

			printf(" %3d ", tu[i][j]);

		printf("\n");

	}



	printf("--------------------------------------------------------------------------------\n");

	/*用Dijkstra算法求有向网G的v0顶点到其余顶点v的最短路径P[v]及其带权长度D[v] */

	/*若p[v][w]为1，则w是从v0到v当前求得最短路径上的顶点                        */

	/*final[v]为1，当且仅当v∈S，即已经求得从v0到v的最短路径                    */



	printf("请输入开始路由(R<=5) v0=R");                    //提示输入

	scanf_s("%d", &v0);          //输入起点对应的数值

	printf("\n");

	v0 = v0 - 1;                    //因为C语言中数组的计数是从0开始的，所以这里v0实际值为输入值减去1

	//打印表头

	printf("开始路由器\t目的网络\t最短路径经过的路由器或网络序列\t最短路径值\n");

	printf("\n");              //回车换行



	for (v = 0; v < 11; ++v)

	{

		final[v] = 0;

		d[v] = tu[v0][v];                  // v0到v的带权长度

		for (w = 0; w < 11; ++w)

			p[v][w] = 0;                  //设空路径

		if (d[v] < INFINITY)

		{

			p[v][v0] = 1;                              //表示v和v0相邻

			p[v][v] = 1;

		}

	}//for

	d[v0] = 0; final[v0] = 1;        //初始化，v0顶点属于S集

	for (i = 0; i < 11; i++)       //初始化，各个节点的前驱节点都默认为v0

		q[i] = v0;



	while (s1--)                             //因为有六个路由节点，所以开始六次循环

	{

		//开始主循环，每次求得v0到某个v顶点的最短路径，并加v到S集

		for (i = 1; i < 11; ++i)

		{                                          //其余10个顶点

			min = INFINITY;                           //当前所知离v0顶点的最近距离

			for (w = 0; w < 11; ++w)

				if (!final[w])                           //w顶点在V-S中

					if (d[w] < min)                        //d[w]==tu[v0][w]

					{

						v = w;

						min = d[w];                         //w顶点离v0顶点更近

					}

			final[v] = 1;                             //离v0顶点最近的v加入S集





			for (w = 0; w < 11; ++w)               //更新当前最短路径及距离

				if (!final[w])

					if (min + tu[v][w] < d[w])

					{                                        //修改d[w]和q[w],w∈V-S

						d[w] = min + tu[v][w];

						q[w] = v;                               //v是v0到w最短路径上的前驱节点                              

						p[w][v] = 1;                            //v是w到v0上最短路径的顶点

						p[w][w] = 1;

					}//if

		}

	}//while

	   //ShortestPath_DIJ

	//把在上面Dijkstra算法中记录的逆序路径正序化，好进行下一步输出

	for (i = 6; i < 11; i++)

	{

		a = q[i];

		s[i - 6][10] = i;

		for (j = 9; j > 0; j--)

		{

			if (a != v0)

			{

				s[i - 6][j] = a;

				a = q[a];

			}

			if (s[i - 6][j] == v0)                      //找到了v0节点则退出循环

				break;

		}

	}



	//输出路径

	for (i = 6; i < 11; i++)

	{

		printf("    %c%c\t\t %c%c\t\t%c%c", str[v0 * 2], str[v0 * 2 + 1], str[2 * i], str[2 * i + 1], str[v0 * 2], str[v0 * 2 + 1]);

		for (j = 0; j < 11; j++)

		{

			if (s[i - 6][j] != 100 && s[i - 6][j] != v0)

			{

				a = 2 * s[i - 6][j];

				b = 2 * s[i - 6][j] + 1;

				printf("一%c%c", str[a], str[b]);

			}

		}

		printf("\t\t\t%d\n", d[i]);                           //输出最短路径的权值

	}//for

	printf("--------------------------------------------------------------------------------");

	//输出路由表

	printf("     目的网络     下一跳（路由器） \n");

	for (i = 6; i < 11; i++)

	{

		printf("\t%c%c        ", str[2 * i], str[2 * i + 1]);

		for (j = 0; j < 11; j++)

		{

			if (s[i - 6][j] != 100 && s[i - 6][j] != v0 && s[i - 6][j] < 6)

			{

				a = 2 * s[i - 6][j];

				b = 2 * s[i - 6][j] + 1;

				printf("\t%c%c\n", str[a], str[b]);

				temp = 1;

				break;

			}

		}

		if (!temp)

			printf("\t--\n");

	}//for

	printf("print any key exit!\n");

}